# 项目介绍

https://www.codefather.cn/course/1948291549923344386/section/1948291654280491010

# 用户模块

## 需求分析

- 注册
- 登录
- 获取当前登录用户
- 注销
- 权限控制
- 【管理员】管理用户

## 对权限进行控制？

- 未登录也可使用
- 登录用户才能使用
- 未登录可以使用，但登录能进行更多操作
- 管理员才能使用

可以通过 Spring AOP + 自定义权限注解。
如果需要更复杂更灵活的权限控制，可以引入 Spring Security/ Shiro/ Sa-Token
等专门的权限管理框架。

# AI 生成应用

使用 LangChain4j 接入 AI 大模型，根据用户的描述自动生成完整的网页应用。

- 设计 AI 应用生成方案
- LangChain4j 框架入门
- 实现 AI 应用生成（2种模式）
- 实现 SSE 流式输出
- 通过多种设计模式优化代码架构

## 原生模式

两种原生模式：

- 原生 HTML 模式: 打包在一个 HTML 中
- 原生多文件模式：index.html + js + css

## LangChain4j

**优势**

- 声明式编程模式
- 模型支持丰富
- 容易集成

需要掌握的特性：

- AI对话- ChatModel
- 多模态 - Multimodality
- 系统提示词 - SystemMessage
- AI服务 - Al Service
- Spring Boot 项目整合
- 会话记忆 - ChatMemory
- 结构化输出
- 检索增强生成-RAG
- 工具调用-Tools
- 模型上下文协议-MCP
- 护轨-Guardrail
- 日志和可观测性

## 结构化输出

创建生成结果类，用于封装 AI 返回的内容。

结构化输出可能出现问题，AI 没有按照标准输出。
通过关键优化技巧可以避免。

1. 设置 max_tokens
   防止 AI 生成的 JSON 被半路截断。
2. 配置 JSON SCHEMA
   OpenAI 相关文档提到了 response_format_json_schema 配置，可以严格确保格式化输出生效。
   但是 DeepSeek 不支持。DS 可以设置 response_format 参数为 `{'type': 'json_object'}`
    ```yaml
   langchain4j:
    open-api:
      chat-model:
        strict-json-schema: true
        response-format: json_object
    ```
3. 为结果类和属性添加详细的描述信息，便于 AI 理解
    ```java
    @Description("生成 HTML 代码文件的结果")
    @Data
    public class HtmlCodeResult {
    
        @Description("HTML代码")
        private String htmlCode;
    
        @Description("生成代码的描述")
        private String description;
    
    }
    ```
4. 在系统提示词中明确要求输出 JSON 格式

经过以上优化，仍然可能会有不稳定的情况。
Langchain4j 默认会自动重试，可以通过 `max_retries` 控制重试次数。

## 程序处理写入 - 门面模式

门面模式提供一个统一的高层接口来隐藏子系统的复杂性。
客户端只需要与这个简化的接口交互，而不用关心背后的细节。

## SSE 流式输出

目前流式输出不支持结构化输出，但可以在流式返回的过程中拼接 AI 的返回结果。

1. LangChain4j + Reactor. 与前端集成更方便
2. TokenStream 原生实现方式，提供了更多高级回调。使用起来较为复杂。

## 代码优化

- 解析器部分：使用策略模式，不同类型的解析策略独立维护（难点是不同解析策略返回值不同）
- 文件保存部分：使用模板方法模式，统一保存流程（难点是不同保存方式方法参数不同）
- SSE 流式处理：抽象出通用的流式处理逻辑

### 策略模式

定义了一系列算法，将每个算法封装起来，让它们可以相互替换，使得算法的变化不会影响使用算法的代码。
让项目更好维护和扩展。

### 模板方法模式

在抽象父类中定义了操作的标准流程，将一些具体实现步骤交给子类，
使得子类可以在不改变流程的情况下重新定义某些特定步骤。

### 执行器模式 Executor

不是标准的设计模式，但是很常用。

正常情况可以通过工厂模式创建不同策略和模板方法，但由于参数和返回值不同，
很难对工厂模式创建出的抽象对象统一调用。

执行器模式提供统一的执行入口来协调不同策略和模板的调用，适合处理参数类型不同但业务逻辑相似的场景。

### 混合模式

最终，预期的代码架构是一种混合模式。

- 门面模式：对外提供统一方法调用
- 执行器模式：提供统一的执行入口，根据代码生成类型执行不同的操作，由门面调用
- 策略模式：每种生成类型对应的解析方法单独作为一个类来维护
- 模板方法模式：抽象模板类定义了通用的文件保存流程，子类可以有自己的实现。（如多文件生成模式保存3个文件）

# 应用模块

• 用户基础功能
• 创建应用
• 编辑应用信息
• 删除自己的应用
• 查看应用详情
• 分页查询自己的应用列表
• 分页查看精选应用列表
• 用户高级功能
• 实时查看应用效果
• 应用部署
• 管理功能
• 管理所有应用（删除、查询、修改）
• 设置精选应用

## 基础应用能力


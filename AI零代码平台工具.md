# 项目介绍

https://www.codefather.cn/course/1948291549923344386/section/1948291654280491010

# 用户模块

## 需求分析

- 注册
- 登录
- 获取当前登录用户
- 注销
- 权限控制
- 【管理员】管理用户

## 对权限进行控制？

- 未登录也可使用
- 登录用户才能使用
- 未登录可以使用，但登录能进行更多操作
- 管理员才能使用

可以通过 Spring AOP + 自定义权限注解。
如果需要更复杂更灵活的权限控制，可以引入 Spring Security/ Shiro/ Sa-Token
等专门的权限管理框架。

# AI 生成应用

使用 LangChain4j 接入 AI 大模型，根据用户的描述自动生成完整的网页应用。

- 设计 AI 应用生成方案
- LangChain4j 框架入门
- 实现 AI 应用生成（2种模式）
- 实现 SSE 流式输出
- 通过多种设计模式优化代码架构

## 原生模式

两种原生模式：

- 原生 HTML 模式: 打包在一个 HTML 中
- 原生多文件模式：index.html + js + css

## LangChain4j

**优势**

- 声明式编程模式
- 模型支持丰富
- 容易集成

需要掌握的特性：

- AI对话- ChatModel
- 多模态 - Multimodality
- 系统提示词 - SystemMessage
- AI服务 - Al Service
- Spring Boot 项目整合
- 会话记忆 - ChatMemory
- 结构化输出
- 检索增强生成-RAG
- 工具调用-Tools
- 模型上下文协议-MCP
- 护轨-Guardrail
- 日志和可观测性

## 结构化输出

创建生成结果类，用于封装 AI 返回的内容。

结构化输出可能出现问题，AI 没有按照标准输出。
通过关键优化技巧可以避免。

1. 设置 max_tokens
   防止 AI 生成的 JSON 被半路截断。
2. 配置 JSON SCHEMA
   OpenAI 相关文档提到了 response_format_json_schema 配置，可以严格确保格式化输出生效。
   但是 DeepSeek 不支持。DS 可以设置 response_format 参数为 `{'type': 'json_object'}`
    ```yaml
   langchain4j:
    open-api:
      chat-model:
        strict-json-schema: true
        response-format: json_object
    ```
3. 为结果类和属性添加详细的描述信息，便于 AI 理解
    ```java
    @Description("生成 HTML 代码文件的结果")
    @Data
    public class HtmlCodeResult {
    
        @Description("HTML代码")
        private String htmlCode;
    
        @Description("生成代码的描述")
        private String description;
    
    }
    ```
4. 在系统提示词中明确要求输出 JSON 格式

经过以上优化，仍然可能会有不稳定的情况。
Langchain4j 默认会自动重试，可以通过 `max_retries` 控制重试次数。

## 程序处理写入 - 门面模式

门面模式提供一个统一的高层接口来隐藏子系统的复杂性。
客户端只需要与这个简化的接口交互，而不用关心背后的细节。

## SSE 流式输出

目前流式输出不支持结构化输出，但可以在流式返回的过程中拼接 AI 的返回结果。

1. LangChain4j + Reactor. 与前端集成更方便
2. TokenStream 原生实现方式，提供了更多高级回调。使用起来较为复杂。

## 代码优化

- 解析器部分：使用策略模式，不同类型的解析策略独立维护（难点是不同解析策略返回值不同）
- 文件保存部分：使用模板方法模式，统一保存流程（难点是不同保存方式方法参数不同）
- SSE 流式处理：抽象出通用的流式处理逻辑

### 策略模式

定义了一系列算法，将每个算法封装起来，让它们可以相互替换，使得算法的变化不会影响使用算法的代码。
让项目更好维护和扩展。

### 模板方法模式

在抽象父类中定义了操作的标准流程，将一些具体实现步骤交给子类，
使得子类可以在不改变流程的情况下重新定义某些特定步骤。

### 执行器模式 Executor

不是标准的设计模式，但是很常用。

正常情况可以通过工厂模式创建不同策略和模板方法，但由于参数和返回值不同，
很难对工厂模式创建出的抽象对象统一调用。

执行器模式提供统一的执行入口来协调不同策略和模板的调用，适合处理参数类型不同但业务逻辑相似的场景。

### 混合模式

最终，预期的代码架构是一种混合模式。

- 门面模式：对外提供统一方法调用
- 执行器模式：提供统一的执行入口，根据代码生成类型执行不同的操作，由门面调用
- 策略模式：每种生成类型对应的解析方法单独作为一个类来维护
- 模板方法模式：抽象模板类定义了通用的文件保存流程，子类可以有自己的实现。（如多文件生成模式保存3个文件）

# 应用模块

• 用户基础功能
• 创建应用
• 编辑应用信息
• 删除自己的应用
• 查看应用详情
• 分页查询自己的应用列表
• 分页查看精选应用列表
• 用户高级功能
• 实时查看应用效果
• 应用部署
• 管理功能
• 管理所有应用（删除、查询、修改）
• 设置精选应用

## 基础应用能力

使用 AI 生成，并优化

## 应用生成

- 用户输入提示词，创建应用
- 获得应用 ID 后跳转到对话页面
- 系统自动使用初始提示词和 AI 对话

## SSE 流式接口优化

### 1. 解决空格丢失问题

- 可以参照 DS 的做法，将原本的返回值封装到 JSON 中。
- 也可以将内容进行加密，再在前端解密（美团 No Code）

### 2. 主动告诉前端完成

SSE 中，服务器关闭连接时，会触发 onclose 事件。但是异常中断时也会触发。

可以在后端添加一个明确的 done 事件。更好区分正常结束和异常中断。

## 应用部署

把本地的文件同步到一个 Web 服务器上。可以是同一个服务器的不同目录（成本低）。

### 部署方案

- 使用 Serve 工具
  最简单，通过 Node.js 的 serve 包快速启动一个 Web 服务器。性能相对较低。
  要提前独立启动 Web 服务进程。依赖 Node 环境。
- 通过 Spring Boot 接口。
  直接在后端实现一个静态资源服务接口。无需额外进程，但功能相对简单，仅适合浏览。
- Nginx 映射
  最推荐的生产方案。性能最好。
- 还可以用 COS 对象存储的静态网站访问能力，同时实现 存储+访问。要求有域名。

使用 Spring Boot 接口实现 AI 生成的网页预览，使用 Nginx 提供网站部署服务。

### 开发

部署接口接收 appId。返回可访问的 URL。

### 功能验收

1. 先确保功能可用，再优化样式和细节
2. 先验收最难实现的功能，或跑通核心业务流程
3. 每次 AI 生成完成后先提交代码，之后每修复一个问题或改动一次就提交一次

# 对话历史模块

- 对话历史游标方案设计
- 对话历史的保存和查询
- 对话记忆持久化
- Redis 分布式 Session

